<!doctype html>
<html>
<head>
  <title>TwinSpark.js docs</title>
  <link rel="stylesheet" href="vendor/spectre.min.css">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="vendor/fetch-mock.js"></script>
  <script src="twinspark.js"></script>
  <script>
    function prev() { return document.currentScript.previousElementSibling.innerText; }

    function escape(s) {
      return s
        .replace(/&quot;/g, '"') // because json-in-attrs will be disgusting
        .replace(/&amp;/g, '&')
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
    }

    function trim(s) {
      return s.replace(/^\n+|\s+$/g, '')
    }

    document.addEventListener('DOMContentLoaded', function() {
      [].forEach.call(document.querySelectorAll('.card'), function(el) {
        var example = el.querySelector('.card-body');
        example.initial = example.innerHTML;
        el.querySelector('.reset').addEventListener('click', function(e) {
          example.innerHTML = example.initial;
          twinspark._internal.init();
        });
        el.querySelector('.source').addEventListener('click', function(e) {
          example.innerHTML = '<pre><code>' +
                              escape(trim(example.initial)) +
                              '</code></pre>';
        });
      });

      [].forEach.call(document.querySelectorAll('h3'), function(el) {
        if (el.id) {
          var a = document.createElement('a');
          a.href = '#' + el.id;
          a.innerText = '#';
          el.append(' ');
          el.append(a);
        }
      });
    });

  </script>
  <style>
    body {padding-bottom: 3em;} /* until we get footer? */
    .card-body {overflow: scroll; }
    .btn-sm {margin-bottom: .2rem; }
  </style>
</head>
<body class="container">
<div class="columns">
<div class="column col-6 col-xl-8 col-lg-10 col-md-12 col-mx-auto">

<h1><a href="/">TwinSpark</a></h1>
<ul>
  <li><a href="https://en.wikipedia.org/wiki/TwinSpark">Dual ignition engines</a>
    from Alfa Romeo, used from 1914 in Grand Prix cars to 2009.</li>
  <li>Declarative enhancement for HTML: simple, composable, lean.</li>
</ul>

<p>TwinSpark was heavily influenced
  by <a href="https://intercoolerjs.org/">Intercooler</a> and the main reasons
  for existing are following:</p>
<ul>
  <li>Intercooler limited (and I don't mean in a bad sense) extensibility meant
    there is no way to implement analytics.</li>
  <li>There is no (official) way to update more than one fragment at the same time.</li>
  <li>As a related problem, there is no way to batch several requests into a single
    one, and our architecture makes that pretty important.</li>
  <li>jQuery. It is 2020 on the streets already, can we just drop that?</li>
</ul>

<p>See at <a href="https://github.com/kasta-ua/twinspark-js">Github</a>.</p>

<!-- TESTS -->
<h2>Tests</h2>
<p>
  This document has tests embedded in examples, to run them, press:
  <button class="btn" onclick="runTests()">Run tests</button>
</p>
<style>
  #wru{font-family:sans-serif;font-size:11pt}
  #wru div{cursor:default;padding:0;color:#000}
  #wru div span,#wru div strong{display:block;padding:4px;margin:0}
  #wru div ul{margin:0;padding-bottom:4px}
  #wru div.pass{background:#90ee90}
  #wru div.fail{background:tomato}
  #wru div.error{background:#000;color:#fff}
</style>
<div id="wru"></div>
<script src="vendor/wru.min.js"></script>
<script>
  var TESTS = [];
  function test(testfn) {
    var parent = document.currentScript.closest('div');
    var example = parent.querySelector('.card-body');
    var h = parent;
    while(h && !((h = h.previousElementSibling).tagName == 'H3')) {
    }

    var test = {
      name: h && h.innerText || 'test',
      setup: () => {
        example.innerHTML = example.initial;
        twinspark.activate(example);
      },
      test: () => {
        try {
          testfn(example)
        } catch (e) {
          console.error(e);
          throw e;
        }
      },
      teardown: () => {
        example.innerHTML = example.initial;
        twinspark.activate(example);
      }
    };
    TESTS.push(test);
  }

  function runTests() {
    Element.prototype.$ = Element.prototype.querySelector;
    Element.prototype.$$ = Element.prototype.querySelectorAll;
    window.event = (type, attrs, el) => {
      var e = new Event(type);
      if (attrs) Object.assign(e, attrs);
      el.dispatchEvent(e);
    }
    window.click = (el) => event('click', {button: 0}, el);
    window.wait = (fn, t) => setTimeout(wru.async(fn, (t || 16) + 16), t || 16);

    TESTS.forEach(t => wru.test(t));
  }
</script>
<!-- END TESTS -->


<hr>

<h2>Guide</h2>

<h3 id="fragment">Fragment updating</h3>
<p>The core feature of TwinSpark.js is it's ability to update fragments of the
  page using AJAX requests to server without writing JavaScript.</p>
<p>To simplify inner logic you have one limitation - you can only return single
  element from the server. If you return more, they will be ignored. How to deal
  with that and why it is so - read on.</p>


<div class="card">
  <div class="card-header">
    <h5 class="d-inline mr-2">Demo</h5>
    <button class="btn btn-link btn-sm reset">Reset</button>
    <button class="btn btn-link btn-sm source">View Source</button>
  </div>

  <p class="card-body">
    <a href="/req" ts-req>Update me</a>
  </p>

  <script type="text/html">
    <a href="/req" ts-req>Updated!</a>
  </script>
  <script>
    fetchMock.get("/req", prev());
    test(el => {
      click(el.$('a'));
      wait(() => wru.assert(el.$('a').innerText == 'Updated!'));
    });
  </script>
</div>


<h3 id="trigger" class="mt-2">Triggering requests</h3>
<p>Usually requests are triggered on natural interrupts: submit on forms and
  clicks elsewhere, but sometimes you want more, like triggering on being seen
  or hovered:</p>

<div class="card">
  <div class="card-header">
    <h5 class="d-inline mr-2">Demo</h5>
    <button class="btn btn-link btn-sm reset">Reset</button>
    <button class="btn btn-link btn-sm source">View Source</button>
  </div>

  <p class="card-body">
    <a href="/trigger" ts-req ts-trigger="mouseenter">Hover me!</a>
  </p>

  <script type="text/html">
    <a href="/trigger" ts-req>Good girl! :)</a>
  </script>
  <script>
    fetchMock.get("/trigger", prev());
    test(el => {
      event('mouseenter', null, el.$('a'));
      wait(() => wru.assert(el.$('a').innerText == 'Good girl! :)'));
    });
  </script>
</div>


<h3 id="before" class="mt-2">Doing stuff before/after request</h3>
<p>If you need to do some custom things around your request, you can use
  <code>ts-req-before</code> and <code>ts-req-after</code>. Those use same
  syntax as <a href="#action"><code>ts-action</code></a>, so it's pretty
  flexible. One additional thing is that if last (or the only) command of
  <code>ts-req-before</code> returns falsy value (<code>false</code>, or
  an empty string, or a zero) - this stops that request.</p>


<div class="card">
  <div class="card-header">
    <h5 class="d-inline mr-2">Demo</h5>
    <button class="btn btn-link btn-sm reset">Reset</button>
    <button class="btn btn-link btn-sm source">View Source</button>
  </div>

  <p class="card-body">
    <a href="/before" ts-req ts-req-before="shortly">This will work with delay</a><br>
    <a href="/before" ts-req ts-req-before="get_user">This is prevented</a>
  </p>

  <script type="text/html">
    <a href="/before" ts-req>Did you see it?</a>
  </script>
  <script>
    twinspark.func({shortly: el => twinspark.delay(300),
                    get_user: el => localStorage.getItem('user')});
    fetchMock.get("/before", prev());
    test(el => {
      click(el.$$('a')[0])
      click(el.$$('a')[1])
      wait(() => wru.assert(el.$$('a')[0].innerText == 'Did you see it?'), 320);
      wait(() => wru.assert(el.$$('a')[1].innerText == 'This is prevented'));
    });
  </script>
</div>


<h3 id="data" class="mt-2">Collecting data</h3>
<p>Sometimes collecting the data you need to send in templates is really
  annoying: you'll have to teach lower-level components/partials/etc some
  knowledge about higher levels. That is something TwinSpark can prevent: when
  you send a request, it iterates through element parents and searches for
  <code>ts-data</code> attributes, parses their content as query string or JSON
  and merges it into a single object. Note how values with same keys are aggregated
  into an array (like normal query string or form data). You can override that by
  specifying key with null or empty string (see demo source).</p>

<div class="card">
  <div class="card-header">
    <h5 class="d-inline mr-2">Demo</h5>
    <button class="btn btn-link btn-sm reset">Reset</button>
    <button class="btn btn-link btn-sm source">View Source</button>
  </div>

  <p class="card-body">
    <span ts-data="a=1&b=2&c=3">
      <!-- this will override 'c' value -->
      <a href="/data" ts-data="b=4&c&c=5" ts-req ts-req-method="POST">So. Much. Data.</a>
    </span>
  </p>

  <script>
    fetchMock.post("/data", function(url, opts) {
      return '<a>' + opts.body + '</a>';
    });
    test(el => {
      click(el.$('a'));
      wait(() => wru.assert(el.$('a').innerText == 'a=1&b=2&b=4&c=5'));
    });
  </script>
</div>


<h3 id="target" class="mt-2">Targeting other elements</h3>
<p>Often you don't want to replace clicked element, but some other part of the
  page, like if you hit "Refresh" and need to update big part of the page. This
  can be done with <code>ts-target</code> attribute, which takes a CSS
  selector.</p>

<div class="card">
  <div class="card-header">
    <h5 class="d-inline mr-2">Demo</h5>
    <button class="btn btn-link btn-sm reset">Reset</button>
    <button class="btn btn-link btn-sm source">View Source</button>
  </div>

  <p class="card-body">
    <span id="replace">I'm waiting...</span>
    <a href="/target" ts-req ts-target="#replace">Do it!</a>
  </p>

  <script type="text/html">
    <span id="replace">Good catch!</span>
  </script>
  <script>
    fetchMock.get("/target", prev());
    test(el => {
      click(el.$('a'));
      wait(() => wru.assert(el.$('span').innerText = 'Good catch!'));
    });
  </script>
</div>


<h3 id="parent" class="mt-2">Targeting parents</h3>
<p>Interestingly, this seems like the most common pattern - when a button needs
  to update an element around itself. Add modifier <code>parent</code> before
  selector and <code>element.closest(selector)</code> method will be used to
  find a parent. This will help a lot to minimize amount of ids.</p>

<div class="card">
  <div class="card-header">
    <h5 class="d-inline mr-2">Demo</h5>
    <button class="btn btn-link btn-sm reset">Reset</button>
    <button class="btn btn-link btn-sm source">View Source</button>
  </div>

  <div class="card-body">
    <p>Wanna read text behind me?
      <a href="/closest" ts-req ts-target="parent p">Do it!</a>
    </p>
  </div>

  <script type="text/html">
    <p>Did you know that introducing too many ids is a symptom of coupling
      logic with markup?</p>
  </script>
  <script>
    fetchMock.get("/closest", prev());
    test(el => {
      click(el.$('a'));
      wait(() => wru.assert(el.$('p').innerText.startsWith('Did you know')));
    });
  </script>
</div>


<h3 id="history" class="mt-2">Changing URLs</h3>
<p>URLs are a fundament of the Web. Changing URLs in line with activity makes your
  app reloadable, browseable with backward/forward button and overall a good
  citizen of the Web.</p>

<div class="card">
  <div class="card-header">
    <h5 class="d-inline mr-2">Demo</h5>
    <button class="btn btn-link btn-sm reset">Reset</button>
    <button class="btn btn-link btn-sm source">View Source</button>
  </div>

  <p class="card-body">
    <a href="/history" ts-req ts-req-history>Let's change history!</a>
  </p>

  <script type="text/html">
    <span>Now check that back button works</span>
  </script>
  <script>
    fetchMock.get("/history", prev());
    test(el => {
      click(el.$('a'));
      wait(() => {
        wru.assert(location.pathname == '/history');
        history.replaceState(null, null, '/');
      });
    });
  </script>
</div>


<h3 id="indicator" class="mt-2">Indicating activity</h3>
<p>It's really irritating when you click a link and nothing happens for some time. Luckily
  TwinSpark makes it really easy: it adds class <code>ts-active</code> to an element, enhanced with <code>ts-req</code>.</p>

<div class="card">
  <div class="card-header">
    <h5 class="d-inline mr-2">Demo</h5>
    <button class="btn btn-link btn-sm reset">Reset</button>
    <button class="btn btn-link btn-sm source">View Source</button>
  </div>

  <p class="card-body">
    <a href="/indicator" class="indicator" ts-req>Just click me</a>
  </p>

  <style>
    .indicator.ts-active {
      min-height: .8rem;
      pointer-events: none;
      position: relative;
    }
    .indicator.ts-active::after {
      animation: loading .5s infinite linear;
      border: .1rem solid #5755d9;
      border-radius: 50%;
      border-right-color: transparent;
      border-top-color: transparent;
      content: "";
      display: block;
      height: .8rem;
      left: 110%;
      margin-left: -.4rem;
      margin-top: -.4rem;
      position: absolute;
      top: 50%;
      width: .8rem;
      z-index: 1;
    }
  </style>

  <script type="text/html">
    <a href="/indicator" class="indicator" ts-req>Just click me</a>
  </script>
  <script>
    (function(markup) {
      fetchMock.get("/indicator", function() {
        return new Promise(res => setTimeout(res, 1000, markup))
      });
    })(prev());
    test(el => {
      click(el.$('a'));
      wait(() => wru.assert(el.$('a').classList.contains('ts-active')));
      //wait(() => wru.assert(!el.$('a').classList.contains('ts-active')), 1050);
    });
  </script>
</div>


<h3 id="actions" class="mt-2">Actions</h3>
<p>Sometimes you don't need to go to server to do something. Closing popup or
  hiding an element can be done without network round trip.</p>


<div class="card">
  <div class="card-header">
    <h5 class="d-inline mr-2">Demo of <code>remove</code></h5>
    <button class="btn btn-link btn-sm reset">Reset</button>
    <button class="btn btn-link btn-sm source">View Source</button>
  </div>

  <div class="card-body">
    <p>
      Hey! I'm here!
      <button class="btn" ts-action="remove" ts-trigger="click" ts-target="parent p">Remove me!</button>
    </p>
  </div>

  <script>
    twinspark.func({remove: el => el.remove()});
    test(el => {
      click(el.$('button'));
      wait(() => wru.assert(el.$('button') == null));
      });
  </script>
</div>


<div class="card">
  <div class="card-header">
    <h5 class="d-inline mr-2">Demo of <code>delay</code></h5>
    <button class="btn btn-link btn-sm reset">Reset</button>
    <button class="btn btn-link btn-sm source">View Source</button>
  </div>

  <div class="card-body">
    <p ts-target="child span">
      <span>Remove with timeout</span>
      <button class="btn" ts-action="loading onesec remove" ts-trigger="click">Do it!</button>
    </p>
  </div>

  <script>
    twinspark.func({loading: el => el.classList.add('loading'),
                    notloading: el => el.classList.remove('loading'),
                    remove: el => el.remove(),
                    onesec: el => twinspark.delay(1000)});
    test(el => {
      click(el.$('button'));
      wait(() => wru.assert(el.$('button')));
      //wait(() => wru.assert(el.$('button')), 1050);
    });
  </script>
</div>


<div class="card">
  <div class="card-header">
    <h5 class="d-inline mr-2">Demo of <code>animate</code> (no Safari here)</h5>
    <button class="btn btn-link btn-sm reset">Reset</button>
    <button class="btn btn-link btn-sm source">View Source</button>
  </div>

  <div class="card-body">
    <p ts-target="this">
      <button class="btn" ts-action="anim" ts-trigger="click">Animate</button>
    </p>
  </div>

  <script>
    twinspark.func({anim: el => el.animate([{transform: "translate3D(0,0,0)"},
                                            {transform: "translate3D(300px,0,0)"}],
                                           {duration: 1000, iterations: 10})});
      // i don't know if it's possible
      /*test*/(el => {
        click(el.$('button'));
        wait(() => {
          console.log(getComputedStyle(el.$('button')).transform);
          wru.assert(getComputedStyle(el.$('button')).transform != 'none')
        }, 100);
      });
  </script>
</div>

<!--
     <h3 id="timer" class="mt-2">Extending with external function</h3>
     <p>In case you need to implement some weird functionality, there is an extension point to </p>


     <div class="card">
     <div class="card-header">
     <h5 class="d-inline mr-2">Demo (no Safari here)</h5>
     <button class="btn btn-link btn-sm reset">Reset</button>
     <button class="btn btn-link btn-sm source">View Source</button>
     </div>

     <div class="card-body">
     <p ts-target="this">
     <time datetime="2022-03-21T00:00:00Z" ts-action="timeUntil" ts-trigger="timeout 1000"></time>
     </p>
     </div>
     </div>
-->


<h3 id="visible" class="mt-2">Triggering on changed visibility</h3>
<p>Doing something when element is almost visible makes it possible to implement lazy
  loading and various analytical events</p>

<div class="card">
  <div class="card-header">
    <h5 class="d-inline mr-2">Demo</h5>
    <button class="btn btn-link btn-sm reset">Reset</button>
    <button class="btn btn-link btn-sm source">View Source</button>
  </div>

  <div class="card-body">
    <p ts-action="loading longer notloading" ts-trigger="visible">
      You'll probably this text after around 5 seconds or so. Click "Reset" to see
      loader again.
    </p>
  </div>

  <script>
    twinspark.func({loading: el => el.classList.add('loading'),
                    notloading: el => el.classList.remove('loading'),
                    longer: el => twinspark.delay(5000)});
  </script>
</div>

<hr>

<h2>Advanced</h2>

<h3 id="batch">Batching requests</h3>
<p>This is a thing which is not immediately obvious, but is one of the reasons why
  TwinSpark appeared. It is an important optimization. Our use case for it was
  following: page renders for an anonymous user (for efficient caching on CDN) and
  then status of wishlisted products is checked. It's a pattern we use often and
  we really wanted it to be a first-class feature.</p>

<div class="card">
  <div class="card-header">
    <h5 class="d-inline mr-2">Demo</h5>
    <button class="btn btn-link btn-sm reset">Reset</button>
    <button class="btn btn-link btn-sm source">View Source</button>
  </div>

  <p class="card-body">
    <span ts-data="campaign=123">
      <span ts-req-batch="/batch" ts-data="id=1" ts-trigger="visible">Span 1</span><br>
      <span ts-req-batch="/batch" ts-data="id=2" ts-trigger="visible">Span 2</span><br>
      <span ts-req-batch="/batch" ts-data="id=3" ts-trigger="visible">Span 3</span><br>
    </span>
  </p>

  <script type="text/html">
    <span>Updated Span 1 by request number</span>
    <span>Updated Span 2 by request number</span>
    <span>Updated Span 3 by request number</span>
  </script>
  <script>
    (function(markup) {
      var n = 1;
      fetchMock.get("path:/batch", function(url, opts) {
        var qs = url.split('?')[1]; // FIXME: как определить ts-req-batch'и?
        //console.log(qs);
        return markup.replace(/ number/g, ' number ' + n++);
      });
    })(prev());
    // how do I emulate "visibility" from intersection observer
    /*test*/(el => {
      wait(() => {
        var spans = el.$('span').children;
        wru.assert(spans[0].innerText.slice(10) == spans[0].innerText.slice(10));
      });
    })
  </script>
</div>
